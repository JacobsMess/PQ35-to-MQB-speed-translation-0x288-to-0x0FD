/*
 * ESP32 VWMITM - Dual CAN Translator
 * 
 * INTENDED BEHAVIOR:
 * - ESP32 CAN (GPIO16/17): Receives 0x288, sends 0x123 heartbeat (A1/A2)
 * - MCP2515 (SPI): Transmits 0x0FD, sends 0x123 heartbeat (B1/B2)
 * 
 * CURRENT ISSUE:
 * - MCP2515 initializes OK (loopback test passes)
 * - But B1/B2 heartbeat never appears on CAN bus
 * - Likely CAN transceiver issue on MCP2515 side
 * 
 * Hardware:
 * - ESP32 CAN: RX=GPIO16, TX=GPIO17
 * - MCP2515: CS=GPIO5, INT=GPIO27, SCK=18, MISO=19, MOSI=23
 * - Crystal: 8MHz (confirmed working in loopback)
 */

#ifndef ARDUINO_ARCH_ESP32
  #error "Select an ESP32 board" 
#endif

#include <ACAN_ESP32.h>
#include <ACAN2515.h>

#define LED_BUILTIN 2

// MCP2515 Hardware Configuration
static const byte MCP2515_SCK  = 18;
static const byte MCP2515_MOSI = 23;
static const byte MCP2515_MISO = 19;
static const byte MCP2515_CS   = 5;
static const byte MCP2515_INT  = 27;
static const uint32_t QUARTZ_FREQUENCY = 8UL * 1000UL * 1000UL;

ACAN2515 bmsCan(MCP2515_CS, SPI, MCP2515_INT);

// State variables
bool translating = false;
unsigned long last288Time = 0;
unsigned long lastHeartbeat = 0;
uint8_t counter_0FD = 0x00;
bool mcpInitialized = false;

// Statistics
unsigned long rx288Count = 0;
unsigned long tx0FDCount = 0;
unsigned long txHeartbeatESP32 = 0;
unsigned long txHeartbeatMCP = 0;

// ===== VAG CRC8 Algorithm (verified correct) =====
const uint8_t magicBytes[16] = {
    0xA3, 0xA9, 0x66, 0x13, 0x85, 0x1F, 0x0D, 0x37,
    0xF0, 0xC2, 0x8E, 0xA1, 0x38, 0xB1, 0x4E, 0xD9
};

uint8_t vag_crc_esp21(const uint8_t *data, int len, uint8_t counter) {
    uint8_t crc = 0x00;
    
    for (int i = 0; i < len; i++) { 
        crc ^= data[i];
        for (int b = 0; b < 8; b++) {
            if (crc & 0x80)
                crc = (crc << 1) ^ 0x2F;
            else
                crc = crc << 1;
        }
    }
    
    return crc ^ magicBytes[counter & 0x0F];
}

void build_payload(uint8_t *payload, const uint8_t *frame) {
    payload[0] = frame[1] & 0xF0;
    for (int i = 0; i < 6; i++) {
        payload[i + 1] = frame[i + 2];
    }
    payload[7] = 0x00;
}

// ===== Translate 0x288 to 0x0FD =====
void translate0x288(const CANMessage &msg288) {
    // Extract speed from D4 (byte 3)
    uint8_t speedByte = msg288.data[3];
    float speedKph = (float)speedByte * 1.28f;
    uint16_t speedValue = (uint16_t)(speedKph * 100.0f + 0.5f);
    
    // Build frame
    uint8_t frame[8] = {0};
    frame[1] = 0xD0 | (counter_0FD & 0x0F);
    frame[2] = 0x1F;
    frame[3] = 0x82;
    frame[4] = (uint8_t)(speedValue & 0xFF);
    frame[5] = (uint8_t)((speedValue >> 8) & 0xFF);
    frame[6] = 0x00;
    frame[7] = 0x00;
    
    // Calculate CRC
    uint8_t payload[8];
    build_payload(payload, frame);
    frame[0] = vag_crc_esp21(payload, 8, counter_0FD);
    
    // Send on MCP2515
    CANMessage msg0FD;
    msg0FD.id = 0x0FD;
    msg0FD.ext = false;
    msg0FD.rtr = false;
    msg0FD.len = 8;
    for (int i = 0; i < 8; i++) {
        msg0FD.data[i] = frame[i];
    }
    
    if (mcpInitialized) {
        if (bmsCan.tryToSend(msg0FD)) {
            tx0FDCount++;
        }
    }
    
    counter_0FD = (counter_0FD + 1) & 0x0F;
}

void setup() {
    pinMode(LED_BUILTIN, OUTPUT);
    digitalWrite(LED_BUILTIN, LOW);
    delay(1000);
    
    // ===== Initialize ESP32 CAN =====
    ACAN_ESP32_Settings settingsESP(500 * 1000);
    settingsESP.mRxPin = GPIO_NUM_16;
    settingsESP.mTxPin = GPIO_NUM_17;
    
    uint32_t errESP = ACAN_ESP32::can.begin(settingsESP);
    
    if (errESP == 0) {
        // ESP32 OK - 1 blink
        digitalWrite(LED_BUILTIN, HIGH);
        delay(200);
        digitalWrite(LED_BUILTIN, LOW);
        delay(500);
    }
    
    // ===== Initialize MCP2515 =====
    SPI.begin(MCP2515_SCK, MCP2515_MISO, MCP2515_MOSI);
    
    ACAN2515Settings settingsMCP(QUARTZ_FREQUENCY, 500UL * 1000UL);
    settingsMCP.mRequestedMode = ACAN2515Settings::NormalMode;
    
    uint16_t errMCP = bmsCan.begin(settingsMCP, [] { bmsCan.isr(); });
    
    if (errMCP == 0) {
        mcpInitialized = true;
        // MCP OK - 2 blinks
        for (int i = 0; i < 2; i++) {
            digitalWrite(LED_BUILTIN, HIGH);
            delay(200);
            digitalWrite(LED_BUILTIN, LOW);
            delay(200);
        }
    } else {
        mcpInitialized = false;
        // MCP FAILED - 5 fast blinks
        for (int i = 0; i < 5; i++) {
            digitalWrite(LED_BUILTIN, HIGH);
            delay(100);
            digitalWrite(LED_BUILTIN, LOW);
            delay(100);
        }
    }
    
    delay(1000);
}

void loop() {
    CANMessage frame;
    
    // ===== Receive 0x288 from ESP32 CAN =====
    while (ACAN_ESP32::can.receive(frame)) {
        if (frame.id == 0x288 && frame.len >= 4) {
            rx288Count++;
            translating = true;
            last288Time = millis();
            
            // Translate and send on MCP2515
            translate0x288(frame);
        }
    }
    
    // ===== Timeout =====
    if (translating && (millis() - last288Time > 500)) {
        translating = false;
    }
    
    // ===== Send 0x123 heartbeat every 100ms on BOTH buses =====
    if (millis() - lastHeartbeat >= 100) {
        lastHeartbeat = millis();
        
        // ESP32 heartbeat: A1 (idle) or A2 (translating)
        CANMessage heartbeatESP;
        heartbeatESP.id = 0x123;
        heartbeatESP.ext = false;
        heartbeatESP.rtr = false;
        heartbeatESP.len = 8;
        uint8_t byteA = translating ? 0xA2 : 0xA1;
        for (int i = 0; i < 8; i++) {
            heartbeatESP.data[i] = byteA;
        }
        
        if (ACAN_ESP32::can.tryToSend(heartbeatESP)) {
            txHeartbeatESP32++;
        }
        
        // MCP2515 heartbeat: B1 (idle) or B2 (translating)
        if (mcpInitialized) {
            CANMessage heartbeatMCP;
            heartbeatMCP.id = 0x123;
            heartbeatMCP.ext = false;
            heartbeatMCP.rtr = false;
            heartbeatMCP.len = 8;
            uint8_t byteB = translating ? 0xB2 : 0xB1;
            for (int i = 0; i < 8; i++) {
                heartbeatMCP.data[i] = byteB;
            }
            
            if (bmsCan.tryToSend(heartbeatMCP)) {
                txHeartbeatMCP++;
            }
        }
        
        // LED blink
        static int blinkCount = 0;
        if (blinkCount++ >= 10) {
            blinkCount = 0;
            digitalWrite(LED_BUILTIN, HIGH);
            delay(50);
            digitalWrite(LED_BUILTIN, LOW);
        }
    }
    
    delay(1);
}

/*
 * DEBUG NOTES:
 * 
 * SYMPTOMS:
 * - MCP2515 initializes successfully (errMCP == 0)
 * - Loopback test passes (chip can send/receive internally)
 * - tryToSend() returns true for both heartbeat and 0x0FD
 * - But NO messages appear on physical CAN bus from MCP2515
 * - ESP32 CAN works perfectly (A1/A2 visible on bus)
 * 
 * THINGS TO CHECK:
 * 1. CAN transceiver connected to MCP2515:
 *    - Is it powered? (usually needs 5V)
 *    - Does it need an enable/standby pin pulled high/low?
 *    - Common transceivers: TJA1050, MCP2551, SN65HVD230
 * 
 * 2. Physical connections:
 *    - Are outer pins actually connected to MCP2515's transceiver?
 *    - Check CANH/CANL from MCP2515 to transceiver to connector
 * 
 * 3. MCP2515 mode:
 *    - Currently set to NormalMode
 *    - Could try ExternalLoopBackMode to test transceiver
 * 
 * 4. Termination:
 *    - Does MCP2515 bus have proper 120Î© termination?
 * 
 * 5. Test with oscilloscope:
 *    - Check if there's ANY activity on MCP2515 TX pin
 *    - Check transceiver outputs (CANH/CANL)
 * 
 * STATISTICS (view via Serial at 115200):
 * - Add Serial.print statements to show:
 *   - rx288Count (should increase when playing 0x288)
 *   - tx0FDCount (should equal rx288Count)
 *   - txHeartbeatESP32 (should increase by 10/sec)
 *   - txHeartbeatMCP (should increase by 10/sec but not on bus)
 */