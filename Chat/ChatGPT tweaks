/*
 * ESP32 VWMITM - ESP32->MCP2515 speed translator
 *
 * Intended behavior:
 * - Listen on ESP32 CAN for 0x288
 * - Translate to 0x0FD (VAG CRC8) and SEND ON MCP2515 CAN
 * - Heartbeat on BOTH buses every 100ms:
 *    ESP32 CAN: 0x123 filled with A1 (idle) / A2 (translating)
 *    MCP2515 : 0x123 filled with B1 (idle) / B2 (translating)
 */

#ifndef ARDUINO_ARCH_ESP32
  #error "Select an ESP32 board"
#endif

#include <ACAN_ESP32.h>
#include <ACAN2515.h>

#define LED_BUILTIN 2

// MCP2515 Hardware
static const byte MCP2515_SCK  = 18;
static const byte MCP2515_MOSI = 23;
static const byte MCP2515_MISO = 19;
static const byte MCP2515_CS   = 5;
static const byte MCP2515_INT  = 27;
static const uint32_t QUARTZ_FREQUENCY = 8UL * 1000UL * 1000UL;

ACAN2515 bmsCan(MCP2515_CS, SPI, MCP2515_INT);

// State tracking
bool translatingESP32 = false;
bool translatingMCP   = false;

unsigned long last288TimeESP32 = 0;   // last time we RECEIVED 0x288 on ESP32
unsigned long last288TimeMCP   = 0;   // last time we SENT a translation on MCP
unsigned long lastHeartbeat    = 0;

bool mcpOK = false;

// Counter used for outgoing 0x0FD frames ON THE MCP BUS
uint8_t counter_0FD_MCP = 0x00;

// ===== VAG CRC8 =====
const uint8_t magicBytes[16] = {
    0xA3, 0xA9, 0x66, 0x13, 0x85, 0x1F, 0x0D, 0x37,
    0xF0, 0xC2, 0x8E, 0xA1, 0x38, 0xB1, 0x4E, 0xD9
};

uint8_t vag_crc_esp21(const uint8_t *data, int len, uint8_t counter) {
    uint8_t crc = 0x00;

    for (int i = 0; i < len; i++) {
        crc ^= data[i];
        for (int b = 0; b < 8; b++) {
            if (crc & 0x80) crc = (crc << 1) ^ 0x2F;
            else           crc = (crc << 1);
        }
    }

    return crc ^ magicBytes[counter & 0x0F];
}

void build_payload(uint8_t *payload, const uint8_t *frame) {
    payload[0] = frame[1] & 0xF0;          // mask off counter nibble
    for (int i = 0; i < 6; i++) {
        payload[i + 1] = frame[i + 2];
    }
    payload[7] = 0x00;
}

// ===== Create 0x0FD message from 0x288 =====
CANMessage create0x0FD(const CANMessage &msg288, uint8_t &counter) {
    // Extract speed from byte index 3 (4th byte)
    uint8_t speedByte = msg288.data[3];
    float speedKph = (float)speedByte * 1.28f;
    uint16_t speedValue = (uint16_t)(speedKph * 100.0f + 0.5f);

    // Build frame bytes
    uint8_t frame[8] = {0};
    frame[1] = 0xD0 | (counter & 0x0F);
    frame[2] = 0x1F;
    frame[3] = 0x82;
    frame[4] = (uint8_t)(speedValue & 0xFF);
    frame[5] = (uint8_t)((speedValue >> 8) & 0xFF);
    frame[6] = 0x00;
    frame[7] = 0x00;

    // Calculate CRC into frame[0]
    uint8_t payload[8];
    build_payload(payload, frame);
    frame[0] = vag_crc_esp21(payload, 8, counter);

    // Increment counter (0..15)
    counter = (counter + 1) & 0x0F;

    // Create CAN message
    CANMessage msg0FD;
    msg0FD.id  = 0x0FD;
    msg0FD.ext = false;
    msg0FD.rtr = false;
    msg0FD.len = 8;
    for (int i = 0; i < 8; i++) msg0FD.data[i] = frame[i];

    return msg0FD;
}

// ===== MCP2515 RX callback =====
// We don't translate based on MCP reception for your use-case,
// but we still drain RX to avoid buffer overflow/interrupt load.
static void receivedFromMCP(const CANMessage &inMessage) {
    (void)inMessage; // intentionally unused
}

void setup() {
    pinMode(LED_BUILTIN, OUTPUT);
    digitalWrite(LED_BUILTIN, LOW);
    delay(1000);

    // ===== ESP32 CAN =====
    ACAN_ESP32_Settings settingsESP(500 * 1000);
    settingsESP.mRxPin = GPIO_NUM_16;
    settingsESP.mTxPin = GPIO_NUM_17;
    ACAN_ESP32::can.begin(settingsESP);

    // 1 blink = ESP32 init
    digitalWrite(LED_BUILTIN, HIGH);
    delay(200);
    digitalWrite(LED_BUILTIN, LOW);
    delay(500);

    // ===== MCP2515 =====
    SPI.begin(MCP2515_SCK, MCP2515_MISO, MCP2515_MOSI);

    ACAN2515Settings settingsMCP(QUARTZ_FREQUENCY, 500UL * 1000UL);
    settingsMCP.mRequestedMode = ACAN2515Settings::NormalMode;

    // Accept all standard frames (mask=0), dispatch to a no-op callback.
    const ACAN2515Mask rxm0 = standard2515Mask(0x000, 0, 0);
    const ACAN2515Mask rxm1 = standard2515Mask(0x000, 0, 0);
    const ACAN2515AcceptanceFilter filters[] = {
        { standard2515Filter(0x000, 0, 0), receivedFromMCP }
    };

    uint16_t errMCP = bmsCan.begin(settingsMCP, [] { bmsCan.isr(); }, rxm0, rxm1, filters, 1);

    if (errMCP == 0) {
        mcpOK = true;
        // 2 blinks = MCP OK
        for (int i = 0; i < 2; i++) {
            digitalWrite(LED_BUILTIN, HIGH);
            delay(200);
            digitalWrite(LED_BUILTIN, LOW);
            delay(200);
        }
    } else {
        mcpOK = false;
        // 5 fast blinks = MCP failed
        for (int i = 0; i < 5; i++) {
            digitalWrite(LED_BUILTIN, HIGH);
            delay(100);
            digitalWrite(LED_BUILTIN, LOW);
            delay(100);
        }
    }

    delay(1000);
}

void loop() {
    CANMessage frame;

    // ===== ESP32 RX: watch for 0x288, translate, send on MCP =====
    while (ACAN_ESP32::can.receive(frame)) {
        if (frame.id == 0x288 && frame.len >= 4) {
            translatingESP32 = true;
            last288TimeESP32 = millis();

            if (mcpOK) {
                CANMessage msg0FD = create0x0FD(frame, counter_0FD_MCP);

                // Send translated 0x0FD on MCP2515 CAN
                if (bmsCan.tryToSend(msg0FD)) {
                    translatingMCP = true;
                    last288TimeMCP = millis();
                } else {
                    // If TX queue is full, we still consider ourselves "active"
                    translatingMCP = true;
                    last288TimeMCP = millis();
                }
            }
        }
    }

    // ===== MCP2515: drain RX (keeps controller healthy if bus is busy) =====
    if (mcpOK) {
        bmsCan.dispatchReceivedMessage();
    }

    // ===== Timeout checks (used for heartbeat state) =====
    if (translatingESP32 && (millis() - last288TimeESP32 > 500)) translatingESP32 = false;
    if (translatingMCP   && (millis() - last288TimeMCP   > 500)) translatingMCP   = false;

    // ===== Send heartbeats every 100ms on BOTH buses =====
    if (millis() - lastHeartbeat >= 100) {
        lastHeartbeat = millis();

        // ESP32 heartbeat: A1 (idle) / A2 (translating)
        CANMessage heartbeatA;
        heartbeatA.id  = 0x123;
        heartbeatA.ext = false;
        heartbeatA.rtr = false;
        heartbeatA.len = 8;
        uint8_t byteA = translatingESP32 ? 0xA2 : 0xA1;
        for (int i = 0; i < 8; i++) heartbeatA.data[i] = byteA;
        ACAN_ESP32::can.tryToSend(heartbeatA);

        // MCP2515 heartbeat: B1 (idle) / B2 (translating)
        if (mcpOK) {
            CANMessage heartbeatB;
            heartbeatB.id  = 0x123;
            heartbeatB.ext = false;
            heartbeatB.rtr = false;
            heartbeatB.len = 8;
            uint8_t byteB = translatingMCP ? 0xB2 : 0xB1;
            for (int i = 0; i < 8; i++) heartbeatB.data[i] = byteB;
            bmsCan.tryToSend(heartbeatB);
        }

        // LED blink (~1Hz)
        static int blinkCount = 0;
        if (blinkCount++ >= 10) {
            blinkCount = 0;
            digitalWrite(LED_BUILTIN, HIGH);
            delay(50);
            digitalWrite(LED_BUILTIN, LOW);
        }
    }

    delay(1);
}

